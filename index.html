<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f0f0f0;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      align-items: center;
    }

    .tool-btn {
      padding: 10px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #007bff;
      color: white;
      font-weight: bold;
    }

    .tool-btn.active {
      background: #0056b3;
    }

    .color-picker {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    .color-btn {
      width: 30px;
      height: 30px;
      border: 2px solid #ccc;
      border-radius: 50%;
      cursor: pointer;
    }

    .color-btn.active {
      border-color: #000;
    }

    #drawingCanvas {
      border: 2px solid #333;
      background: white;
      cursor: crosshair;
      display: block;
      margin: 0 auto;
    }

    .status {
      margin-top: 10px;
      text-align: center;
      color: #666;
    }

    .shapes-panel {
      margin: 15px 0;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .shape-btn {
      padding: 8px 12px;
      border: 1px solid #007bff;
      background: white;
      color: #007bff;
      border-radius: 4px;
      cursor: pointer;
    }

    .shape-btn__tool {
      width: 40px;
      height: 40px;
      padding: 0;
    }

    .shape-btn__tool img {
      display: block;
      width: 100%;
      height: 100%;
      padding: 0;
      object-fit: contain;
    }

    .shape-btn:hover {
      background: #007bff;
      color: white;
    }

    .snap-options {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-left: auto;
    }

    .help-text {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>–ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è —Å –ø—Ä–∏–≤—è–∑–∫–æ–π</h1>

    <div class="controls">
      <button class="tool-btn active" data-tool="draw">‚úèÔ∏è –†–∏—Å–æ–≤–∞—Ç—å</button>
      <button class="tool-btn" data-tool="select">üîç –í—ã–¥–µ–ª–∏—Ç—å</button>
      <button class="tool-btn" data-tool="move">‚ÜîÔ∏è –ü–µ—Ä–µ–º–µ—â–∞—Ç—å</button>
      <button class="tool-btn" data-tool="delete">üóëÔ∏è –£–¥–∞–ª–∏—Ç—å</button>

      <div class="color-picker">
        <div class="color-btn active" style="background: black;" data-color="black"></div>
        <div class="color-btn" style="background: red;" data-color="red"></div>
        <div class="color-btn" style="background: blue;" data-color="blue"></div>
        <div class="color-btn" style="background: green;" data-color="green"></div>
        <input type="color" id="customColor" value="#000000">
      </div>

      <input type="range" id="brushSize" min="1" max="20" value="3">
      <span id="sizeValue">3px</span>

      <div class="snap-options">
        <label>
          <input type="checkbox" id="snapToGrid" checked>
          –ü—Ä–∏–≤—è–∑–∫–∞ –∫ —Å–µ—Ç–∫–µ
        </label>
        <label>
          <input type="checkbox" id="snapToPoints" checked>
          –ü—Ä–∏–≤—è–∑–∫–∞ –∫ —Ç–æ—á–∫–∞–º
        </label>
      </div>
    </div>

    <div class="shapes-panel">
      <strong>–î–æ–±–∞–≤–∏—Ç—å —Ñ–∏–≥—É—Ä—ã:</strong>
      <button class="shape-btn" data-shape="rectangle">‚¨ú –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫</button>
      <button class="shape-btn" data-shape="circle">üîµ –ö—Ä—É–≥</button>
      <button class="shape-btn" data-shape="triangle">üî∫ –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫</button>
      <button class="shape-btn" data-shape="star">‚≠ê –ó–≤–µ–∑–¥–∞</button>

      <!-- –ö–Ω–æ–ø–∫–∏ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏ -->
      <button data-shape="production" class="shape-btn shape-btn__tool">
        <img src="./img/prohod.png" alt="–í—ã—Ä–∞–±–æ—Ç–∫–∞" title="–í—ã—Ä–∞–±–æ—Ç–∫–∞">
      </button>
      <button data-shape="mainfan" class="shape-btn shape-btn__tool">
        <img src="./img/fan.png" alt="–í–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä" title="–í–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä –≥–ª–∞–≤–Ω–æ–≥–æ –ø—Ä–æ–≤–µ—Ç—Ä–∏–≤–∞–Ω–∏—è">
      </button>
      <button data-shape="localfan" class="shape-btn shape-btn__tool">
        <img src="./img/fan2.png" alt="–í–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä –º–µ—Å—Ç–Ω–æ–≥–æ –ø—Ä–æ–≤–µ—Ç—Ä–∏–≤–∞–Ω–∏—è" title="–í–µ–Ω—Ç–∏–ª—è—Ç–æ—Ä –º–µ—Å—Ç–Ω–æ–≥–æ –ø—Ä–æ–≤–µ—Ç—Ä–∏–≤–∞–Ω–∏—è">
      </button>
      <button data-shape="emergencyexit" class="shape-btn shape-btn__tool">
        <img src="./img/zapasvhod.png" alt="–ó–∞–ø–∞—Å–Ω–æ–π –≤—ã—Ö–æ–¥" title="–ó–∞–ø–∞—Å–Ω–æ–π –≤—ã—Ö–æ–¥">
      </button>
      <button data-shape="superstructurebuilding" class="shape-btn shape-btn__tool">
        <img src="./img/nadshahtnoe.png" alt="–ù–∞–¥—à–∞—Ö—Ç–Ω–æ–µ –∑–¥–∞–Ω–∏–µ" title="–ù–∞–¥—à–∞—Ö—Ç–Ω–æ–µ –∑–¥–∞–Ω–∏–µ">
      </button>
      <button data-shape="selfpropelledequipment" class="shape-btn shape-btn__tool">
        <img src="./img/samohodnoe.png" alt="–°–∞–º–æ—Ö–æ–¥–Ω–æ–µ –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ" title="–°–∞–º–æ—Ö–æ–¥–Ω–æ–µ –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ">
      </button>
      <button data-shape="people" class="shape-btn shape-btn__tool">
        <img src="./img/people.png" alt="–õ—é–¥–∏" title="–õ—é–¥–∏">
      </button>
      <button data-shape="fire" class="shape-btn shape-btn__tool">
        <img src="./img/fire.png" alt="–ü–æ–∂–∞—Ä" title="–ü–æ–∂–∞—Ä">
      </button>
      <button data-shape="bridgeisconcrete" class="shape-btn shape-btn__tool">
        <img src="./img/petemichkabeton.png" alt="–ü–µ—Ä–µ–º—ã—á–∫–∞ –±–µ—Ç–æ–Ω–Ω–∞—è" title="–ü–µ—Ä–µ–º—ã—á–∫–∞ –±–µ—Ç–æ–Ω–Ω–∞—è">
      </button>
      <button data-shape="woodenlintel" class="shape-btn shape-btn__tool">
        <img src="./img/petemichkawood.png" alt="–ü–µ—Ä–µ–º—ã—á–∫–∞ –¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è" title="–ü–µ—Ä–µ–º—ã—á–∫–∞ –¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è">
      </button>
      <button data-shape="bricklintel" class="shape-btn shape-btn__tool">
        <img src="./img/petemichkakirpich.png" alt="–ü–µ—Ä–µ–º—ã—á–∫–∞ –∫–∏—Ä–ø–∏—á–Ω–∞—è" title="–ü–µ—Ä–µ–º—ã—á–∫–∞ –∫–∏—Ä–ø–∏—á–Ω–∞—è">
      </button>
      <button data-shape="bridgeismeta" class="shape-btn shape-btn__tool">
        <img src="./img/petemichkametall.png" alt="–ü–µ—Ä–µ–º—ã—á–∫–∞ –º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∞—è" title="–ü–µ—Ä–µ–º—ã—á–∫–∞ –º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∞—è">
      </button>
      <button data-shape="doorisclosed" class="shape-btn shape-btn__tool">
        <img src="./img/dvercloses.png" alt="–î–≤–µ—Ä—å –∑–∞–∫—Ä—ã—Ç–∞—è (–±–µ—Ç–æ–Ω–Ω–∞—è)" title="–î–≤–µ—Ä—å –∑–∞–∫—Ä—ã—Ç–∞—è (–±–µ—Ç–æ–Ω–Ω–∞—è)">
      </button>
      <button data-shape="doorwithventwindow" class="shape-btn shape-btn__tool">
        <img src="./img/dverwentoknowood.png" alt="–î–≤–µ—Ä—å —Å –≤–µ–Ω—Ç–æ–∫–Ω–æ–º (–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è)"
          title="–î–≤–µ—Ä—å —Å –≤–µ–Ω—Ç–æ–∫–Ω–æ–º (–¥–µ—Ä–µ–≤—è–Ω–Ω–∞—è)">
      </button>
      <button data-shape="doorisopen" class="shape-btn shape-btn__tool">
        <img src="./img/dveropenmetall.png" alt="–î–≤–µ—Ä—å –æ—Ç–∫—Ä—ã—Ç–∞—è (–º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∞—è)" title="–î–≤–µ—Ä—å –æ—Ç–∫—Ä—ã—Ç–∞—è (–º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∞—è)">
      </button>
      <button data-shape="doorislatticed" class="shape-btn shape-btn__tool">
        <img src="./img/dverventrech.png" alt="–î–≤–µ—Ä—å —Ä–µ—à–µ—Ç—á–∞—Ç–∞—è (–∫–∏—Ä–ø–∏—á–Ω–∞—è —Å—Ç–µ–Ω–∞)"
          title="–î–≤–µ—Ä—å —Ä–µ—à–µ—Ç—á–∞—Ç–∞—è (–∫–∏—Ä–ø–∏—á–Ω–∞—è —Å—Ç–µ–Ω–∞)">
      </button>
      <button data-shape="warehousefirematerials" class="shape-btn shape-btn__tool">
        <img src="./img/scladprotivopozar.png" alt="–°–∫–ª–∞–¥ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–∂–∞—Ä–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤"
          title="–°–∫–ª–∞–¥ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–∂–∞—Ä–Ω—ã—Ö –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤">
      </button>
      <button data-shape="telephone" class="shape-btn shape-btn__tool">
        <img src="./img/phone.png" alt="–¢–µ–ª–µ—Ñ–æ–Ω" title="–¢–µ–ª–µ—Ñ–æ–Ω">
      </button>
      <button data-shape="firehydrant" class="shape-btn shape-btn__tool">
        <img src="./img/pozarniigidrant.png" alt="–ü–æ–∂–∞—Ä–Ω—ã–π –≥–∏–¥—Ä–∞–Ω—Ç" title="–ü–æ–∂–∞—Ä–Ω—ã–π –≥–∏–¥—Ä–∞–Ω—Ç">
      </button>
      <button data-shape="medicalcenter" class="shape-btn shape-btn__tool">
        <img src="./img/medpunkt.png" alt="–ú–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–π –ø—É–Ω–∫—Ç" title="–ú–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–π –ø—É–Ω–∫—Ç">
      </button>
      <button data-shape="pumpingstation" class="shape-btn shape-btn__tool">
        <img src="./img/nasosnayastancia.png" alt="–ù–∞—Å–æ—Å–Ω–∞—è —Å—Ç–∞–Ω—Ü–∏—è" title="–ù–∞—Å–æ—Å–Ω–∞—è —Å—Ç–∞–Ω—Ü–∏—è">
      </button>
      <button data-shape="submersiblepump" class="shape-btn shape-btn__tool">
        <img src="./img/nanospogruznoi.png" alt="–ù–∞—Å–æ—Å –ø–æ–≥—Ä—É–∂–Ω–æ–π" title="–ù–∞—Å–æ—Å –ø–æ–≥—Ä—É–∂–Ω–æ–π">
      </button>
      <button data-shape="blastingoperations" class="shape-btn shape-btn__tool">
        <img src="./img/vzrivnieraboti.png" alt="–ú–∞—Å—Å–æ–≤—ã–µ –≤–∑—Ä—ã–≤–Ω—ã–µ —Ä–∞–±–æ—Ç—ã" title="–ú–∞—Å—Å–æ–≤—ã–µ –≤–∑—Ä—ã–≤–Ω—ã–µ —Ä–∞–±–æ—Ç—ã">
      </button>
      <button data-shape="massiveblastingoperations" class="shape-btn shape-btn__tool">
        <img src="./img/massovievzivniepaboti.png" alt="–ú–∞—Å—Å–æ–≤—ã–µ –≤–∑—Ä—ã–≤–Ω—ã–µ —Ä–∞–±–æ—Ç—ã" title="–ú–∞—Å—Å–æ–≤—ã–µ –≤–∑—Ä—ã–≤–Ω—ã–µ —Ä–∞–±–æ—Ç—ã">
      </button>
      <button data-shape="separation" class="shape-btn shape-btn__tool">
        <img src="./img/separation.webp" alt="–†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å" title="–†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å">
      </button>
      <button data-shape="allArr" class="shape-btn">–ü–æ–ª—É—á–∏—Ç—å –≤–µ—Å—å –º–∞—Å—Å–∏–≤</button>
      <button class="shape-btn">Save image</button>
    </div>

    <canvas id="drawingCanvas" width="800" height="500"></canvas>

    <div class="status">
      –¢–µ–∫—É—â–∏–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: <span id="currentTool">–†–∏—Å–æ–≤–∞–Ω–∏–µ</span> |
      –¶–≤–µ—Ç: <span id="currentColor">–ß–µ—Ä–Ω—ã–π</span> |
      –†–∞–∑–º–µ—Ä: <span id="currentSize">3px</span> |
      –ü—Ä–∏–≤—è–∑–∫–∞: <span id="snapStatus">–í–∫–ª—é—á–µ–Ω–∞</span>
    </div>

    <div class="help-text">
      üí° <strong>–°–æ–≤–µ—Ç—ã:</strong>
      ‚Ä¢ –£–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ SHIFT –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–≥–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã—Ö/–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã—Ö –ª–∏–Ω–∏–π<br>
      ‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–∏–≤—è–∑–∫—É –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è<br>
      ‚Ä¢ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ —Ñ–∏–≥—É—Ä—ã –∏ –ª–∏–Ω–∏–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–º "–ü–µ—Ä–µ–º–µ—â–∞—Ç—å"
    </div>
  </div>

  <script>
    class DrawingApp {
      constructor() {
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.currentTool = 'draw';
        this.currentColor = 'black';
        this.brushSize = 3;
        this.isDrawing = false;
        this.lastX = 0;
        this.lastY = 0;
        this.shapes = [];
        this.selectedShape = null;
        this.snapToGrid = true;
        this.snapToPoints = true;
        this.gridSize = 20;
        this.tempLine = null;
        this.isShiftPressed = false;
        this.dragOffset = { x: 0, y: 0 };

        // –û–±—ä–µ–∫—Ç —Å –ø—É—Ç—è–º–∏ –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º
        this.imagePaths = {
          production: './img/prohod.png',
          mainfan: './img/fan.png',
          localfan: './img/fan2.png',
          emergencyexit: './img/zapasvhod.png',
          superstructurebuilding: './img/nadshahtnoe.png',
          selfpropelledequipment: './img/samohodnoe.png',
          people: './img/people.png',
          fire: './img/fire.png',
          bridgeisconcrete: './img/petemichkabeton.png',
          woodenlintel: './img/petemichkawood.png',
          bricklintel: './img/petemichkakirpich.png',
          bridgeismeta: './img/petemichkametall.png',
          doorisclosed: './img/dvercloses.png',
          doorwithventwindow: './img/dverwentoknowood.png',
          doorisopen: './img/dveropenmetall.png',
          doorislatticed: './img/dverventrech.png',
          warehousefirematerials: './img/scladprotivopozar.png',
          telephone: './img/phone.png',
          firehydrant: './img/pozarniigidrant.png',
          medicalcenter: './img/medpunkt.png',
          pumpingstation: './img/nasosnayastancia.png',
          submersiblepump: './img/nanospogruznoi.png',
          blastingoperations: './img/vzrivnieraboti.png',
          massiveblastingoperations: './img/massovievzivniepaboti.png',
          separation: './img/separation.webp'
        };

        // –ö—ç—à –¥–ª—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
        this.imageCache = {};

        // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
        this.preloadAllImages();

        this.init();
      }

      // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
      async preloadAllImages() {
        const loadPromises = [];

        for (const [type, path] of Object.entries(this.imagePaths)) {
          loadPromises.push(this.loadImage(type, path));
        }

        try {
          await Promise.all(loadPromises);
          console.log('–í—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã');
          this.redraw(); // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º canvas –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
        } catch (error) {
          console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π:', error);
        }
      }

      // –ó–∞–≥—Ä—É–∑–∫–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      loadImage(type, path) {
        return new Promise((resolve, reject) => {
          // –ï—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ, —Å—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
          if (this.imageCache[type] && this.imageCache[type].complete) {
            resolve(this.imageCache[type]);
            return;
          }

          const img = new Image();
          img.onload = () => {
            this.imageCache[type] = img;
            console.log(`–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ: ${type}`);
            resolve(img);
          };
          img.onerror = () => {
            console.error(`–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${type} (${path})`);
            reject(new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: ${type}`));
          };
          img.src = path;
        });
      }

      init() {
        this.setupEventListeners();
        this.resizeCanvas();
        this.redraw();
      }

      setupEventListeners() {
        // –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
        document.querySelectorAll('.tool-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.setTool(e.target.dataset.tool);
          });
        });

        // –¶–≤–µ—Ç–∞
        document.querySelectorAll('.color-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.setColor(e.target.dataset.color);
          });
        });

        document.getElementById('customColor').addEventListener('input', (e) => {
          this.setColor(e.target.value);
        });

        // –†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏
        const brushSize = document.getElementById('brushSize');
        brushSize.addEventListener('input', (e) => {
          this.brushSize = parseInt(e.target.value);
          document.getElementById('sizeValue').textContent = `${this.brushSize}px`;
          document.getElementById('currentSize').textContent = `${this.brushSize}px`;
        });

        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä
        document.querySelectorAll('.shape-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É "–ü–æ–ª—É—á–∏—Ç—å –≤–µ—Å—å –º–∞—Å—Å–∏–≤"
            if (btn.dataset.shape === 'allArr') return;

            this.addShape(btn.dataset.shape);
          });
        });

        // –ö–Ω–æ–ø–∫–∞ "–ü–æ–ª—É—á–∏—Ç—å –≤–µ—Å—å –º–∞—Å—Å–∏–≤"
        document.querySelector('[data-shape="allArr"]').addEventListener('click', () => {
          this.getAllShapes();
        });

        // –ü—Ä–∏–≤—è–∑–∫–∞
        document.getElementById('snapToGrid').addEventListener('change', (e) => {
          this.snapToGrid = e.target.checked;
          this.updateSnapStatus();
        });

        document.getElementById('snapToPoints').addEventListener('change', (e) => {
          this.snapToPoints = e.target.checked;
          this.updateSnapStatus();
        });

        // –°–æ–±—ã—Ç–∏—è canvas
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mouseout', this.handleMouseUp.bind(this));

        // –ö–ª–∞–≤–∏—à–∏
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));

        // –†–µ—Å–∞–π–∑ –æ–∫–Ω–∞
        window.addEventListener('resize', this.resizeCanvas.bind(this));
      }

      handleKeyDown(e) {
        if (e.key === 'Shift') {
          this.isShiftPressed = true;
        }
      }

      handleKeyUp(e) {
        if (e.key === 'Shift') {
          this.isShiftPressed = false;
        }
      }

      setTool(tool) {
        this.currentTool = tool;

        document.querySelectorAll('.tool-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`[data-tool="${tool}"]`).classList.add('active');

        switch (tool) {
          case 'draw':
            this.canvas.style.cursor = 'crosshair';
            break;
          case 'select':
            prompt("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã");
            this.canvas.style.cursor = 'pointer';
            break;
          case 'move':
            this.canvas.style.cursor = 'move';
            break;
          case 'delete':
            this.canvas.style.cursor = 'not-allowed';
            break;
        }

        document.getElementById('currentTool').textContent =
          tool === 'draw' ? '–†–∏—Å–æ–≤–∞–Ω–∏–µ' :
            tool === 'select' ? '–í—ã–¥–µ–ª–µ–Ω–∏–µ' :
              tool === 'move' ? '–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ' : '–£–¥–∞–ª–µ–Ω–∏–µ';
      }

      setColor(color) {
        this.currentColor = color;

        document.querySelectorAll('.color-btn').forEach(btn => {
          btn.classList.remove('active');
        });

        const colorBtn = document.querySelector(`[data-color="${color}"]`);
        if (colorBtn) {
          colorBtn.classList.add('active');
        }

        document.getElementById('currentColor').textContent = color;
        document.getElementById('currentColor').style.color = color;
      }

      updateSnapStatus() {
        const status = this.snapToGrid || this.snapToPoints ? '–í–∫–ª—é—á–µ–Ω–∞' : '–í—ã–∫–ª—é—á–µ–Ω–∞';
        document.getElementById('snapStatus').textContent = status;
      }

      snapPosition(x, y) {
        let snappedX = x;
        let snappedY = y;

        if (this.snapToGrid) {
          snappedX = Math.round(x / this.gridSize) * this.gridSize;
          snappedY = Math.round(y / this.gridSize) * this.gridSize;
        }

        if (this.snapToPoints) {
          let closestDistance = Infinity;
          let closestPoint = { x: snappedX, y: snappedY };

          this.shapes.forEach(shape => {
            if (shape.type === 'line') {
              shape.points.forEach(point => {
                const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                if (distance < 15 && distance < closestDistance) {
                  closestDistance = distance;
                  closestPoint = point;
                }
              });
            } else {
              const points = [
                { x: shape.x, y: shape.y },
                { x: shape.x + shape.width, y: shape.y },
                { x: shape.x, y: shape.y + shape.height },
                { x: shape.x + shape.width, y: shape.y + shape.height },
                { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }
              ];

              points.forEach(point => {
                const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                if (distance < 15 && distance < closestDistance) {
                  closestDistance = distance;
                  closestPoint = point;
                }
              });
            }
          });

          if (closestDistance < 15) {
            snappedX = closestPoint.x;
            snappedY = closestPoint.y;
          }
        }

        return { x: snappedX, y: snappedY };
      }

      handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;

        const snapped = this.snapPosition(x, y);
        x = snapped.x;
        y = snapped.y;

        this.isDrawing = true;
        this.lastX = x;
        this.lastY = y;

        if (this.currentTool === 'draw') {
          this.tempLine = {
            points: [{ x, y }],
            color: this.currentColor,
            width: this.brushSize
          };
        } else {
          this.selectShape(x, y);

          if (this.selectedShape) {
            if (this.selectedShape.type === 'line') {
              const firstPoint = this.selectedShape.points[0];
              this.dragOffset = {
                x: x - firstPoint.x,
                y: y - firstPoint.y
              };
            } else {
              this.dragOffset = {
                x: x - this.selectedShape.x,
                y: y - this.selectedShape.y
              };
            }
          }

          if (this.currentTool === 'delete' && this.selectedShape) {
            this.shapes = this.shapes.filter(shape => shape !== this.selectedShape);
            this.selectedShape = null;
            this.redraw();
          }
        }
      }

      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;

        const snapped = this.snapPosition(x, y);
        x = snapped.x;
        y = snapped.y;

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ SHIFT –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ø—Ä—è–º—ã—Ö –ª–∏–Ω–∏–π
        if (this.isShiftPressed && this.isDrawing && this.currentTool === 'draw' && this.tempLine) {
          const startPoint = this.tempLine.points[0];
          const dx = Math.abs(x - startPoint.x);
          const dy = Math.abs(y - startPoint.y);

          if (dx > dy) {
            y = startPoint.y;
          } else {
            x = startPoint.x;
          }
        }

        if (this.isDrawing) {
          if (this.currentTool === 'draw') {
            if (this.tempLine) {
              if (this.tempLine.points.length > 1) {
                this.tempLine.points.pop();
              }
              this.tempLine.points.push({ x, y });
              this.redraw();
            }
          } else if (this.currentTool === 'move' && this.selectedShape) {
            this.moveShape(x, y);
          }
        }

        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∏–≤—è–∑–∫—É
        if (this.snapToGrid || this.snapToPoints) {
          this.showSnapIndicator(x, y);
        }
      }

      moveShape(x, y) {
        if (this.selectedShape.type === 'line') {
          const dx = x - this.lastX;
          const dy = y - this.lastY;

          const newPoints = [];
          this.selectedShape.points.forEach(point => {
            newPoints.push({
              x: point.x + dx,
              y: point.y + dy
            });
          });

          this.selectedShape.points = newPoints;
        } else {
          this.selectedShape.x = x - this.dragOffset.x;
          this.selectedShape.y = y - this.dragOffset.y;
        }

        this.lastX = x;
        this.lastY = y;
        this.redraw();
      }

      showSnapIndicator(x, y) {
        this.redraw();
        this.ctx.save();
        this.ctx.strokeStyle = '#ff0000';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([2, 2]);
        this.ctx.beginPath();
        this.ctx.arc(x, y, 5, 0, 2 * Math.PI);
        this.ctx.stroke();
        this.ctx.restore();
      }

      handleMouseUp() {
        if (!this.isDrawing) return;

        this.isDrawing = false;

        if (this.currentTool === 'draw' && this.tempLine && this.tempLine.points.length > 1) {
          this.shapes.push({
            type: 'line',
            points: [...this.tempLine.points],
            color: this.tempLine.color,
            width: this.tempLine.width
          });
          this.tempLine = null;
          this.redraw();
        }
      }

      addShape(type) {
        const x = Math.round(this.canvas.width / 2 / this.gridSize) * this.gridSize;
        const y = Math.round(this.canvas.height / 2 / this.gridSize) * this.gridSize;

        const shape = {
          type,
          x,
          y,
          width: 50,
          height: 50,
          color: this.currentColor
        };

        // –ï—Å–ª–∏ —ç—Ç–æ —Ñ–∏–≥—É—Ä–∞ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º, —É–±–µ–∂–¥–∞–µ–º—Å—è —á—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ
        if (this.imagePaths[type]) {
          this.loadImage(type, this.imagePaths[type])
            .then(() => {
              this.shapes.push(shape);
              this.selectedShape = shape;
              this.redraw();
              console.log(`–§–∏–≥—É—Ä–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞: ${type}`);
            })
            .catch(error => {
              console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ñ–∏–≥—É—Ä—ã ${type}:`, error);
              // –í—Å–µ —Ä–∞–≤–Ω–æ –¥–æ–±–∞–≤–ª—è–µ–º —Ñ–∏–≥—É—Ä—É, –Ω–æ –±–µ–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
              this.shapes.push(shape);
              this.selectedShape = shape;
              this.redraw();
            });
        } else {
          // –î–ª—è –æ–±—ã—á–Ω—ã—Ö —Ñ–∏–≥—É—Ä –±–µ–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
          this.shapes.push(shape);
          this.selectedShape = shape;
          this.redraw();
          console.log(`–§–∏–≥—É—Ä–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞: ${type}`);
        }
      }

      selectShape(x, y) {
        this.selectedShape = null;

        for (let i = this.shapes.length - 1; i >= 0; i--) {
          const shape = this.shapes[i];

          if (this.isPointInShape(x, y, shape)) {
            this.selectedShape = shape;
            break;
          }
        }
        this.redraw();
      }

      isPointInShape(x, y, shape) {
        if (shape.type === 'line') {
          for (let i = 0; i < shape.points.length - 1; i++) {
            const p1 = shape.points[i];
            const p2 = shape.points[i + 1];

            const distance = this.pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
            if (distance < shape.width + 5) return true;
          }
          return false;
        }

        return x >= shape.x && x <= shape.x + shape.width &&
          y >= shape.y && y <= shape.y + shape.height;
      }

      pointToLineDistance(x, y, x1, y1, x2, y2) {
        const A = x - x1;
        const B = y - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;

        if (len_sq !== 0) param = dot / len_sq;

        let xx, yy;

        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }

        const dx = x - xx;
        const dy = y - yy;

        return Math.sqrt(dx * dx + dy * dy);
      }

      redraw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.snapToGrid) {
          this.drawGrid();
        }

        this.shapes.forEach(shape => {
          this.drawShape(shape);
        });

        if (this.tempLine) {
          this.drawShape(this.tempLine);
        }

        if (this.selectedShape) {
          this.highlightShape(this.selectedShape);
        }
      }

      drawGrid() {
        this.ctx.save();
        this.ctx.strokeStyle = '#e0e0e0';
        this.ctx.lineWidth = 0.5;

        for (let x = 0; x <= this.canvas.width; x += this.gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, this.canvas.height);
          this.ctx.stroke();
        }

        for (let y = 0; y <= this.canvas.height; y += this.gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(this.canvas.width, y);
          this.ctx.stroke();
        }

        this.ctx.restore();
      }

      drawShape(shape) {
        this.ctx.save();

        if (shape.type === 'line') {
          this.ctx.beginPath();
          this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
          for (let i = 1; i < shape.points.length; i++) {
            this.ctx.lineTo(shape.points[i].x, shape.points[i].y);
          }
          this.ctx.strokeStyle = shape.color;
          this.ctx.lineWidth = shape.width;
          this.ctx.lineCap = 'round';
          this.ctx.stroke();
        } else if (this.imagePaths[shape.type]) {
          // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ñ–∏–≥—É—Ä —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏
          const cachedImage = this.imageCache[shape.type];
          if (cachedImage && cachedImage.complete) {
            this.ctx.drawImage(cachedImage, shape.x, shape.y, shape.width, shape.height);
          } else {
            // –ï—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ, —Ä–∏—Å—É–µ–º placeholder
            this.ctx.fillStyle = 'lightgray';
            this.ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.strokeStyle = 'gray';
            this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);

            this.ctx.fillStyle = 'black';
            this.ctx.font = '10px Arial';
            this.ctx.fillText('–ó–∞–≥—Ä—É–∑–∫–∞...', shape.x + 5, shape.y + 25);
          }
        } else {
          // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –æ–±—ã—á–Ω—ã—Ö —Ñ–∏–≥—É—Ä
          this.ctx.fillStyle = shape.color;

          switch (shape.type) {
            case 'rectangle':
              this.ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
              break;
            case 'circle':
              this.ctx.beginPath();
              this.ctx.arc(shape.x + shape.width / 2, shape.y + shape.height / 2, shape.width / 2, 0, 2 * Math.PI);
              this.ctx.fill();
              break;
            case 'triangle':
              this.ctx.beginPath();
              this.ctx.moveTo(shape.x + shape.width / 2, shape.y);
              this.ctx.lineTo(shape.x + shape.width, shape.y + shape.height);
              this.ctx.lineTo(shape.x, shape.y + shape.height);
              this.ctx.closePath();
              this.ctx.fill();
              break;
            case 'star':
              this.drawStar(shape.x + shape.width / 2, shape.y + shape.height / 2, 5, shape.width / 2, shape.width / 4);
              this.ctx.fill();
              break;
          }
        }

        this.ctx.restore();
      }

      drawStar(cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx;
        let y = cy;
        let step = Math.PI / spikes;

        this.ctx.beginPath();
        this.ctx.moveTo(cx, cy - outerRadius);

        for (let i = 0; i < spikes; i++) {
          x = cx + Math.cos(rot) * outerRadius;
          y = cy + Math.sin(rot) * outerRadius;
          this.ctx.lineTo(x, y);
          rot += step;

          x = cx + Math.cos(rot) * innerRadius;
          y = cy + Math.sin(rot) * innerRadius;
          this.ctx.lineTo(x, y);
          rot += step;
        }

        this.ctx.lineTo(cx, cy - outerRadius);
        this.ctx.closePath();
      }

      highlightShape(shape) {
        this.ctx.save();
        this.ctx.strokeStyle = '#ff0000';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([5, 5]);

        if (shape.type === 'line') {
          const bounds = this.getLineBounds(shape);
          this.ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
        } else {
          this.ctx.strokeRect(shape.x - 5, shape.y - 5, shape.width + 10, shape.height + 10);
        }

        this.ctx.restore();
      }

      getLineBounds(line) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        line.points.forEach(point => {
          minX = Math.min(minX, point.x);
          minY = Math.min(minY, point.y);
          maxX = Math.max(maxX, point.x);
          maxY = Math.max(maxY, point.y);
        });

        return {
          x: minX - 5,
          y: minY - 5,
          width: maxX - minX + 10,
          height: maxY - minY + 10
        };
      }

      getAllShapes() {
        console.log('–í—Å–µ —Ñ–∏–≥—É—Ä—ã –Ω–∞ —Ö–æ–ª—Å—Ç–µ:', this.shapes);

        const imageShapes = this.shapes.filter(shape => this.imagePaths[shape.type]);
        console.log('–§–∏–≥—É—Ä—ã —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏:', imageShapes);

        alert(`–í—Å–µ–≥–æ —Ñ–∏–≥—É—Ä: ${this.shapes.length}\n–§–∏–≥—É—Ä —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏: ${imageShapes.length}\n–°–º–æ—Ç—Ä–∏—Ç–µ –∫–æ–Ω—Å–æ–ª—å –¥–ª—è –¥–µ—Ç–∞–ª–µ–π.`);

        return this.shapes;
      }

      getLines() {
        return this.shapes.filter(shape => shape.type === 'line');
      }

      resizeCanvas() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth - 40;
        this.redraw();
      }
    }

    let drawingApp;

    document.addEventListener('DOMContentLoaded', () => {
      drawingApp = new DrawingApp();
      window.drawingApp = drawingApp; // –î–µ–ª–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ–π –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏

      // const saveImgBtn = document.querySelector(".shape-btn");

      // saveImgBtn.addEventListener('click', () => {
      //   canvas.toDataURL('image/png');
      // })
    });
  </script>
</body>

</html>